<?xml version="1.0" encoding="UTF-8"?>
<!--
Sprint Plan Template (v5.0)
LLM-optimized XML format for sprint breakdown and dependency graph
Generated by: /tasks command during epic workflow
Purpose: Enable parallel sprint execution based on dependency analysis
-->

<sprint_plan>
  <metadata>
    <epic_number>{{EPIC_NUMBER}}</epic_number>
    <epic_slug>{{EPIC_SLUG}}</epic_slug>
    <total_sprints>{{TOTAL_SPRINTS}}</total_sprints>
    <total_estimated_hours>{{TOTAL_HOURS}}</total_estimated_hours>
    <generated>{{GENERATED_TIMESTAMP}}</generated>
  </metadata>

  <sprints>
    {{#SPRINTS}}
    <sprint id="{{SPRINT_ID}}" number="{{SPRINT_NUMBER}}">
      <metadata>
        <name>{{SPRINT_NAME}}</name>
        <description>{{SPRINT_DESCRIPTION}}</description>
        <estimated_hours>{{ESTIMATED_HOURS}}</estimated_hours>
        <complexity>{{COMPLEXITY}}</complexity> <!-- low | medium | high -->
        <risk_level>{{RISK_LEVEL}}</risk_level> <!-- low | medium | high -->
      </metadata>

      <dependencies>
        <!-- List of sprint IDs this sprint depends on -->
        <!-- Empty if no dependencies (can run immediately) -->
        {{#DEPENDS_ON}}
        <depends_on sprint_id="{{DEPENDENCY_SPRINT_ID}}" reason="{{REASON}}">
          {{DEPENDENCY_DESCRIPTION}}
          <!-- Example: "Requires authentication API from S01 to implement frontend login" -->
        </depends_on>
        {{/DEPENDS_ON}}
      </dependencies>

      <subsystems>
        <!-- Which subsystems this sprint modifies -->
        {{#SUBSYSTEMS}}
        <subsystem name="{{SUBSYSTEM_NAME}}" primary="{{IS_PRIMARY}}">
          <!-- primary: true if this is the main focus, false if just touched -->
          {{SUBSYSTEM_CHANGES}}
        </subsystem>
        {{/SUBSYSTEMS}}
      </subsystems>

      <contracts>
        <!-- API contracts this sprint produces or consumes -->
        <contracts_produced>
          {{#CONTRACTS_PRODUCED}}
          <contract type="{{CONTRACT_TYPE}}" path="{{CONTRACT_PATH}}" locked="{{IS_LOCKED}}">
            <!-- type: openapi | graphql | grpc | event_schema -->
            <!-- locked: true means contract frozen for parallel work -->
            <summary>{{CONTRACT_SUMMARY}}</summary>
            <consumers>{{CONSUMER_SPRINT_IDS}}</consumers>
          </contract>
          {{/CONTRACTS_PRODUCED}}
        </contracts_produced>

        <contracts_consumed>
          {{#CONTRACTS_CONSUMED}}
          <contract type="{{CONTRACT_TYPE}}" path="{{CONTRACT_PATH}}" provider="{{PROVIDER_SPRINT_ID}}">
            <summary>{{CONTRACT_SUMMARY}}</summary>
          </contract>
          {{/CONTRACTS_CONSUMED}}
        </contracts_consumed>
      </contracts>

      <tasks>
        <!-- Task IDs from tasks.xml assigned to this sprint -->
        <task_ids>{{TASK_IDS}}</task_ids> <!-- Comma-separated: T001,T002,T005,T006 -->
        <task_count>{{TASK_COUNT}}</task_count>
      </tasks>

      <acceptance_criteria>
        <!-- Sprint-level acceptance criteria (higher level than task acceptance) -->
        {{#CRITERIA}}
        <criterion id="{{CRITERION_ID}}" category="{{CATEGORY}}">
          <!-- category: functional | performance | security | accessibility | quality -->
          <description>{{DESCRIPTION}}</description>
          <validation_method>{{VALIDATION}}</validation_method>
          <priority>{{PRIORITY}}</priority> <!-- must_have | should_have | nice_to_have -->
        </criterion>
        {{/CRITERIA}}
      </acceptance_criteria>

      <risks>
        <!-- Sprint-specific risks identified during planning -->
        {{#RISKS}}
        <risk id="{{RISK_ID}}" severity="{{SEVERITY}}" probability="{{PROBABILITY}}">
          <!-- severity: low | medium | high | critical -->
          <!-- probability: low | medium | high -->
          <description>{{RISK_DESCRIPTION}}</description>
          <mitigation>{{MITIGATION_STRATEGY}}</mitigation>
          <contingency>{{CONTINGENCY_PLAN}}</contingency>
        </risk>
        {{/RISKS}}
      </risks>

      <parallelization>
        <!-- Metadata for parallel execution engine -->
        <can_run_parallel>{{CAN_PARALLEL}}</can_run_parallel> <!-- true | false -->
        <layer>{{EXECUTION_LAYER}}</layer> <!-- 1, 2, 3, ... -->
        <estimated_parallel_speedup>{{SPEEDUP}}</estimated_parallel_speedup> <!-- 1.0 = no speedup, 2.0 = 2x faster -->
      </parallelization>
    </sprint>
    {{/SPRINTS}}
  </sprints>

  <execution_layers>
    <!-- Dependency-aware execution order for parallel implementation -->
    <!-- Layer N can only start after Layer N-1 completes -->
    {{#LAYERS}}
    <layer number="{{LAYER_NUMBER}}">
      <sprint_ids>{{SPRINT_IDS}}</sprint_ids> <!-- Comma-separated -->
      <parallelizable>{{CAN_PARALLEL}}</parallelizable> <!-- true if sprints in this layer can run simultaneously -->
      <depends_on_layer>{{DEPENDS_ON_LAYER}}</depends_on_layer> <!-- null for layer 1 -->
      <estimated_duration_hours>{{ESTIMATED_HOURS}}</estimated_duration_hours> <!-- Max of parallel sprints, not sum -->
      <rationale>{{RATIONALE}}</rationale>
      <!-- Example: "S01 and S02 have no dependencies, can run in parallel" -->
      <!-- Example: "S03 depends on S01 output (API contract), must wait for layer 1" -->
    </layer>
    {{/LAYERS}}
  </execution_layers>

  <critical_path>
    <!-- Critical path analysis: longest chain of dependent sprints -->
    <path>
      <sprint_ids>{{CRITICAL_PATH_SPRINT_IDS}}</sprint_ids>
      <total_duration_sequential>{{SEQUENTIAL_HOURS}}</total_duration_sequential> <!-- h -->
      <total_duration_parallel>{{PARALLEL_HOURS}}</total_duration_parallel> <!-- h -->
      <speedup_factor>{{SPEEDUP}}</speedup_factor> <!-- parallel / sequential -->
    </path>

    <bottleneck_sprint id="{{BOTTLENECK_ID}}">
      <reason>{{BOTTLENECK_REASON}}</reason>
      <!-- Example: "S02 blocks 3 other sprints and has highest estimated hours" -->
      <mitigation>{{MITIGATION}}</mitigation>
      <!-- Example: "Lock API contract early to unblock dependent sprints" -->
    </bottleneck_sprint>
  </critical_path>

  <contract_locking_strategy>
    <!-- Strategy for locking contracts before parallel work begins -->
    {{#CONTRACT_LOCKS}}
    <lock sprint_id="{{SPRINT_ID}}" phase="{{LOCK_PHASE}}">
      <!-- phase: before_planning | during_tasks | before_implementation -->
      <contract_path>{{CONTRACT_PATH}}</contract_path>
      <reason>{{LOCK_REASON}}</reason>
      <consumers>{{CONSUMER_SPRINT_IDS}}</consumers>
      <locked_date>{{LOCKED_DATE}}</locked_date>
    </lock>
    {{/CONTRACT_LOCKS}}
  </contract_locking_strategy>

  <resource_allocation>
    <!-- Recommended allocation strategy for parallel execution -->
    <peak_parallel_sprints>{{PEAK_PARALLEL}}</peak_parallel_sprints>
    <recommended_agents>{{RECOMMENDED_AGENTS}}</recommended_agents>
    <!-- Example: "3 agents recommended: 1 for backend (S01), 1 for frontend (S02), 1 for database (S03)" -->

    {{#AGENT_ASSIGNMENTS}}
    <assignment layer="{{LAYER_NUMBER}}" sprint_id="{{SPRINT_ID}}">
      <agent_type>{{AGENT_TYPE}}</agent_type> <!-- backend-dev | frontend-dev | database-architect -->
      <rationale>{{RATIONALE}}</rationale>
    </assignment>
    {{/AGENT_ASSIGNMENTS}}
  </resource_allocation>

  <validation_strategy>
    <!-- How to validate cross-sprint integration -->
    <integration_points>
      {{#INTEGRATION_POINTS}}
      <integration sprint_a="{{SPRINT_A_ID}}" sprint_b="{{SPRINT_B_ID}}">
        <interface>{{INTERFACE_DESCRIPTION}}</interface>
        <!-- Example: "Frontend (S02) calls backend API (S01) for authentication" -->
        <validation_tests>{{TEST_PATHS}}</validation_tests>
        <smoke_test>{{SMOKE_TEST_COMMAND}}</smoke_test>
      </integration>
      {{/INTEGRATION_POINTS}}
    </integration_points>

    <integration_testing_layer>{{INTEGRATION_LAYER}}</integration_testing_layer>
    <!-- Which layer to run integration tests: usually after all sprints complete -->

    <rollback_strategy>
      <!-- How to handle failures in one sprint -->
      <policy>{{ROLLBACK_POLICY}}</policy>
      <!-- abort_all: Stop all parallel sprints if one fails -->
      <!-- continue_independent: Continue sprints without dependencies on failed sprint -->
      <!-- mark_and_continue: Mark failed sprint, continue all, fix at end -->
    </rollback_strategy>
  </validation_strategy>

  <optimization_opportunities>
    <!-- Identified opportunities to improve sprint plan -->
    {{#OPPORTUNITIES}}
    <opportunity type="{{TYPE}}" impact="{{IMPACT}}">
      <!-- type: dependency_reduction | contract_early_locking | sprint_splitting | sprint_merging -->
      <!-- impact: low | medium | high -->
      <description>{{DESCRIPTION}}</description>
      <recommendation>{{RECOMMENDATION}}</recommendation>
      <estimated_time_saved_hours>{{TIME_SAVED}}</estimated_time_saved_hours>
    </opportunity>
    {{/OPPORTUNITIES}}
  </optimization_opportunities>

  <revision_history>
    <!-- Track changes to sprint plan during epic execution -->
    <revision number="1" timestamp="{{INITIAL_TIMESTAMP}}" reason="Initial sprint plan generated">
      Initial breakdown from /tasks phase
    </revision>

    {{#REVISIONS}}
    <revision number="{{REVISION_NUMBER}}" timestamp="{{TIMESTAMP}}" reason="{{REASON}}">
      {{CHANGES_DESCRIPTION}}
      <!-- Example: "Sprint S02 split into S02a and S02b due to complexity" -->
      <!-- Example: "Dependency from S03 to S01 removed after contract validation" -->
    </revision>
    {{/REVISIONS}}
  </revision_history>
</sprint_plan>
