# Migration Plan: [FEATURE_NAME]

> Generated by Spec-Flow /plan phase
> Source: spec.md schema analysis

---

## Overview

**Feature**: [FEATURE_SLUG]
**Generated**: [TIMESTAMP]
**Framework**: [Alembic | Prisma] (auto-detected)

---

## Change Classification

| Attribute | Value |
|-----------|-------|
| **Change Type** | [additive | breaking | mixed] |
| **Risk Level** | [low | medium | high] |
| **Zero-Downtime Required** | [yes | no] |
| **Estimated Migration Time** | [< 1 min | 1-5 min | 5+ min] |

**Rationale**: [Brief explanation of classification]

---

## Schema Changes

### New Tables

{IF new_tables}
#### Table: `[table_name]`

**Purpose**: [Description from spec]

| Column | Type | Constraints | Purpose |
|--------|------|-------------|---------|
| `id` | UUID | PK, DEFAULT gen_random_uuid() | Primary key |
| `[column]` | [TYPE] | [NOT NULL, UNIQUE, etc.] | [Purpose] |
| `created_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Audit |
| `updated_at` | TIMESTAMP | NOT NULL | Audit |

**Relationships**:
- `[fk_column]` FK -> `[parent_table].[column]` (ON DELETE [CASCADE|SET NULL|RESTRICT])

**Indexes**:
- `ix_[table]_[column]` ON (`[column]`) - [Rationale: frequently queried]
- `ix_[table]_[fk]` ON (`[fk_column]`) - [Rationale: foreign key lookup]

{ELSE}
*No new tables required*
{ENDIF}

---

### Modified Tables

{IF modified_tables}
#### Table: `[existing_table]`

| Change | Column | From | To | Breaking |
|--------|--------|------|-----|----------|
| ADD | `[column]` | - | `[TYPE] [CONSTRAINTS]` | No |
| MODIFY | `[column]` | `[old_type]` | `[new_type]` | Yes |
| DROP | `[column]` | `[type]` | - | Yes |
| RENAME | `[old_name]` | - | `[new_name]` | Yes |

**Impact on Existing Data**:
- [Describe impact, e.g., "Existing rows will have NULL for new column"]
- [Required backfill: "Set default value for existing rows"]

{ELSE}
*No table modifications required*
{ENDIF}

---

## Breaking Change Analysis

{IF breaking_changes}
### Breaking Changes Detected

| Change | Impact | Risk | Migration Strategy |
|--------|--------|------|-------------------|
| [change description] | [Impact on existing code/data] | [low/medium/high] | [Expand-contract/Dual-write] |

### Zero-Downtime Migration Pattern

**Pattern**: Expand-Contract (safe for breaking changes)

**Phase 1: Expand** (deploy first)
- Add new column as NULLABLE
- Deploy code that writes to BOTH old and new columns (dual-write)
- No breaking changes yet

**Phase 2: Migrate** (after Phase 1 deployed)
- Backfill existing data: `UPDATE [table] SET [new_col] = [transformation] WHERE [new_col] IS NULL`
- Verify data integrity: `SELECT COUNT(*) FROM [table] WHERE [new_col] IS NULL`

**Phase 3: Contract** (after Phase 2 verified)
- Add NOT NULL constraint (if required)
- Remove dual-write code
- Update reads to use new column

**Phase 4: Cleanup** (after 7+ days)
- Drop old column
- Remove backward-compatibility code

{ELSE}
### No Breaking Changes

All changes are **additive** and backward compatible:
- New columns are nullable or have defaults
- No columns dropped or renamed
- No type changes

Safe to deploy in single migration.
{ENDIF}

---

## Migration Sequence

Execute migrations in this order:

### Migration 1: `001_[description].py`

**Type**: DDL (CREATE TABLE | ALTER TABLE)
**Reversible**: Yes

```sql
-- Upgrade
[SQL statement]

-- Downgrade
[Reverse SQL statement]
```

**Validation**:
```sql
-- Verify migration applied
SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = '[table]');
```

### Migration 2: `002_[description].py`

**Type**: DDL (ALTER TABLE ADD COLUMN)
**Depends On**: Migration 1
**Reversible**: Yes

```sql
-- Upgrade
ALTER TABLE [table] ADD COLUMN [column] [TYPE] [CONSTRAINTS];

-- Downgrade
ALTER TABLE [table] DROP COLUMN [column];
```

---

## Data Validation Queries

Run after migration to verify integrity:

```sql
-- Check table exists
SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = '[table]');

-- Check foreign key integrity (no orphans)
SELECT COUNT(*) AS orphaned_rows
FROM [child_table] c
WHERE c.[fk_column] NOT IN (SELECT id FROM [parent_table]);
-- Expected: 0

-- Check NOT NULL constraints honored
SELECT COUNT(*) AS null_violations
FROM [table]
WHERE [required_column] IS NULL;
-- Expected: 0

-- Check unique constraints
SELECT [unique_column], COUNT(*)
FROM [table]
GROUP BY [unique_column]
HAVING COUNT(*) > 1;
-- Expected: empty result
```

---

## Generated Tasks (for /tasks)

The following migration tasks should be generated in **Phase 1.5**:

```markdown
### T001: [MIGRATION] Create [table] table
**Depends On**: T000 (Setup)
**Delegated To**: database-architect
**Priority**: P0 (BLOCKING)
**Framework**: [Alembic | Prisma]
**Source**: migration-plan.md

**Acceptance Criteria**:
- [ ] Migration file created with upgrade()/downgrade()
- [ ] Table schema matches migration-plan.md
- [ ] Foreign keys reference existing tables
- [ ] Indexes created per plan
- [ ] Migration up/down cycle tested
- [ ] Data validation: 0 integrity violations

---

### T002: [MIGRATION] Add indexes for [table]
**Depends On**: T001
**Delegated To**: database-architect
**Priority**: P0 (BLOCKING)

**Acceptance Criteria**:
- [ ] Index on [column] for [reason]
- [ ] EXPLAIN ANALYZE shows index scan
- [ ] Query performance < 50ms

---

### T010: Create [Model] ORM model
**Depends On**: T001, T002 (Migrations MUST complete first)
**Delegated To**: backend-dev
**Priority**: P1

**Acceptance Criteria**:
- [ ] ORM model matches migration schema
- [ ] Relationships defined correctly
- [ ] Basic CRUD operations tested
```

---

## Framework-Specific Commands

### Alembic (Python)

```bash
# Generate migration
cd api && alembic revision --autogenerate -m "[description]"

# Apply migrations
alembic upgrade head

# Rollback one migration
alembic downgrade -1

# Check current revision
alembic current

# View migration history
alembic history
```

### Prisma (TypeScript)

```bash
# Generate migration
npx prisma migrate dev --name [description]

# Apply migrations (production)
npx prisma migrate deploy

# Reset database (development only)
npx prisma migrate reset

# Check migration status
npx prisma migrate status

# Generate Prisma client
npx prisma generate
```

---

## Notes

- **Auto-detected framework**: [Alembic | Prisma] from [package.json | requirements.txt | pyproject.toml]
- **Database**: [PostgreSQL | MySQL | SQLite] from [data-architecture.md | DATABASE_URL]
- **Existing schema**: [N] tables documented in `docs/project/data-architecture.md`

---

*Generated by Spec-Flow /plan phase migration detection*
